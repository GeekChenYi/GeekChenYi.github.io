---
title: 操作符用法高级
date: 2021-04-15 10:56:02
permalink: /pages/6e11ac76475a2b3e
author: GeekChenYi
categories: 
  - 《TypeScript》学习笔记
  - TypeScript 高级语法
tags: 
  - 
---

## keyof

TS允许我们遍历某种类型的属性，并通过 `keyof` 操作符提取其属性的名称。`keyof` 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。

```typescript
interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[];  // number | "length" | "push" | "concat" | ...
type K3 = keyof { [x: string]: Person };  // string | number
```

除了接口外，keyof 也可以用于操作类，比如：

```typescript
class Person {
  name: string = "Semlinker";
}

let sname: keyof Person;
sname = "name";

// 如果更改sname的值

sname = "age" // 报错
```

keyof 操作符除了支持接口和类之外，它也支持基本数据类型：

```typescript
let K1: keyof boolean; // let K1: "valueOf"
let K2: keyof number; // let K2: "toString" | "toFixed" | "toExponential" | ...
let K3: keyof symbol; // let K1: "valueOf"
```

## typeof

typeof 操作符用于获取变量的类型，因此这个操作符的后面接的始终是一个变量，且需要运用到类型定义当中。

typeof和keyof操作符结合在一起使用的例子：

```typescript
const COLORS = {
  red: '红色',
  blue: 12
}

// 首先通过typeof操作符获取color变量的类型，然后通过keyof操作符获取该类型的所有键，
// 即字符串字面量联合类型 'red' | 'blue'
type Geek = typeof COLORS // { red: string, blue: number }

type Colors = keyof typeof COLORS 
let color: Colors;
color = 'red' // Ok
color = 24 // Ok

// Type '"yellow"' is not assignable to type '"red" | "blue"'.
color = 'yellow' // Error
```

## infer

infer关键词常在条件类型中和 extends关键词一同出现，表示将要推断的类型，作为类型变量可以在三元表达式的 True 部分引用。而下文中 ReturnType正是使用这种方式提取到了函数的返回类型。

用于函数入参

```typescript

type ParamType<T> = T extends (param: infer P) => any ? P : T;

```

在这个条件语句 `T extends (param: infer P) => any ? P : T`中，`infer P` 表示待推断的函数参数。

整句表示为：如果 T 能赋值给函数`(param: infer P) => any`，则结果类型是 函数`(param: infer P) => any`类型中的参数 P，否则返回为 T。

用于函数返回值，下边的ReturnType类型就是了

## 内置类型 ReturnType

ReturnType<T>的作用是用于获取函数 T 的返回类型


```typescript
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Obtain the return type of a function type
 */
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;
```

在这个条件语句 `T extends (...args: any) => infer R? R : any中，infer P` 表示待推断的函数返回值

```typescript

type T0 = ReturnType<() => string>; // string
type T1 = ReturnType<(s: string) => void>; // void
type T2 = ReturnType<<T>() => T>; // {}
type T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]
type T4 = ReturnType<any>; // any
type T5 = ReturnType<never>; // any
type T6 = ReturnType<string>; // Error
type T7 = ReturnType<Function>; // Error

```

## TS中Omit帮助类的用法

Omit<K,T>类型让我们可以从另一个对象类型中剔除某些属性，并创建一个新的对象类型：

K：是对象类型名称，T：是剔除K类型中的属性名称

```typescript
type UserProps = {
    name?: string;
    age?: number;
    sex?: string
}

// 但是我不希望有sex这个属性，就可以按照下边的方式写

type NewUserProps = Omit<UserProps, 'sex'>

// 等价于

type NewUserProps = {
    name?: string;
    age?: number;
}
```